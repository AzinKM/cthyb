#include <triqs/utility/first_include.hpp>

#include <cmath>
#include <string>
#include <vector>
#include <cstdlib>
#include <boost/math/special_functions.hpp>

#include <triqs/arrays.hpp>
#include <triqs/arrays/matrix.hpp>
#include <triqs/gf/imtime.hpp>
#include <triqs/gf/block.hpp>
#include <triqs/gf/gf.hpp>
#include <applications/impurity_solvers/ctqmc_krylov/ctqmc.hpp>

using namespace triqs::app::impurity_solvers::ctqmc_krylov;

using boost::math::factorial;
using boost::math::pow;

double three_j_symbol(int j1, int m1,
                      int j2, int m2,
                      int j3, int m3)
{
    // Check if the arguments are physical
    if(m1+m2+m3 != 0 ||
        m1 < -j1 || m1 > j1 ||
        m2 < -j2 || m2 > j2 ||
        m3 < -j3 || m3 > j3 ||
        j3 > j1 + j2 || j3 < std::abs(j1 - j2)
    ) return .0;
        
    double result = ((j1-j2-m3) % 2) ? -1 : 1;
    result *= std::sqrt(
        factorial<double>(j1+j2-j3)*
        factorial<double>(j1-j2+j3)*
        factorial<double>(-j1+j2+j3)/
        factorial<double>(j1+j2+j3+1)
    );
    result *= std::sqrt(
        factorial<double>(j1-m1)*factorial<double>(j1+m1)*
        factorial<double>(j2-m2)*factorial<double>(j2+m2)*
        factorial<double>(j3-m3)*factorial<double>(j3+m3)
    );
    
    int t_min = std::max(std::max(j2-j3-m1,j1-j3+m2),0);
    int t_max = std::min(std::min(j1-m1,j2+m2),j1+j2-j3);
    double t_sum = 0;
    for(int t = t_min; t <= t_max; ++t)
        t_sum += ((t % 2) ? -1 : 1) /
            (
                factorial<double>(t)*
                factorial<double>(j3-j2+m1+t)*
                factorial<double>(j3-j1-m2+t)*
                factorial<double>(j1+j2-j3-t)*
                factorial<double>(j1-m1-t)*
                factorial<double>(j2+m2-t)
            );
       
    result *= t_sum; 
    return result;
}

// Angular matrix elements A_k(m'_1, m'_2, m_2, m_1)
// (l is an angular momentum of a single electron)  
double angular_matrix_element(int l, int k, int mp1, int mp2, int m2, int m1)
{
    double result = 0;
    
    for(int q=-k; q <= k; ++q)
        result += 
            three_j_symbol(l,-mp1,k,-q,l,m2)*
            three_j_symbol(l,-mp2,k,q,l,m1)*
            ((mp1+q+mp2) % 2 ? -1 : 1);
    
    result *= pow<2>(2*l+1)*pow<2>(three_j_symbol(l,0,k,0,l,0));
    
    return result;
}

int main(int argc, char **argv)
{
    // Co in Cu multiorbital test
    
    std::cout << "Welcome to the Krylov solver\n";
    
    // Initialize mpi
    boost::mpi::environment env(argc, argv);
    
    // Input parameters
    const double beta = 40;
    const int L = 2; // d-orbital
    const double mu = 26;
    const double U = 4.0;
    const double J = 0.7;
    
    const int N_comp = 2*L+1;
    
    // Hybridization function parameters
    // Delta(\tau) is diagonal in the basis of cubic harmonics
    // Each component of Delta(\tau) is represented as a list of single-particle
    // terms parametrized by pairs (V_k,\epsilon_k).
    std::vector<std::list<std::pair<double,double>>> delta_params(N_comp);
    delta_params[0].emplace_back(std::make_pair(0.2,-0.2));
    delta_params[1].emplace_back(std::make_pair(0.2,-0.15));
    delta_params[2].emplace_back(std::make_pair(0.2,-0.1));
    delta_params[3].emplace_back(std::make_pair(0.2,0.05));
    delta_params[4].emplace_back(std::make_pair(0.2,0.4));
    
    parameters p;
    p["beta"] = beta;
    p["max_time"] = -1;
    p["Random_Generator_Name"] = "";
    p["Random_Seed"] = 628374;
    p["Verbosity"] = 1;
    p["Length_Cycle"] = 100;
    p["N_Warmup_Cycles"] = 5000;
    p["N_Cycles"] = 10000;
   
    // Local Hamiltonian
    // Changed indices to int, int in the main code for compilation
    typedef triqs::utility::many_body_operator<std::string, std::string> local_operator_t; 
    local_operator_t H;
    
    std::vector<std::string> block_names = {"up","down"};
    std::vector<std::string> cubic_names = {"xy","yz","z^2","xz","x^2-y^2"};

    // Chemical potential
    using triqs::utility::n;
    for(auto const& b_n : block_names)
        for(auto const& c_n : cubic_names)
            H += -mu*n(b_n, c_n);
            
    // Full interaction matrix
    // Basis of spherical harmonics Y_{-2}, Y_{-1}, Y_{0}, Y_{1}, Y_{2}
    triqs::arrays::array<double,4> U_matrix_sph(N_comp,N_comp,N_comp,N_comp);
    
    double F0 = U;
    double F2 = J*(14.0/1.625);
    double F4 = F2*0.625;
    
    for(int mp1 = -L; mp1 <= L; ++mp1)
    for(int mp2 = -L; mp2 <= L; ++mp2)
    for(int m1 = -L; m1 <= L; ++m1)
    for(int m2 = -L; m2 <= L; ++m2){
        // m1 <-> m2: 'Field theory' notation
        U_matrix_sph(mp1+L,mp2+L,m1+L,m2+L) = 
            F0 * angular_matrix_element(L,0,mp1,mp2,m2,m1) +
            F2 * angular_matrix_element(L,2,mp1,mp2,m2,m1) +
            F4 * angular_matrix_element(L,4,mp1,mp2,m2,m1);
    }
    
    // Full interaction matrix
    // Basis of cubic harmonics d_{xy}, d_{yz}, d_{3z^2-r^2}, d_{xz}, d_{x^2-y^2}
    triqs::arrays::array<std::complex<double>,4> U_matrix_cube(N_comp,N_comp,N_comp,N_comp);
    
    // Basis transformation matrix
    triqs::arrays::matrix<std::complex<double>> W(N_comp,N_comp); W() = 0;
    const double inv_sqrt2 = 1.0/std::sqrt(2);
    const std::complex<double> I(0,1.0);
    W(0,0) = I*inv_sqrt2; W(0,4) = -I*inv_sqrt2;
    W(1,1) = I*inv_sqrt2; W(1,3) = I*inv_sqrt2;
    W(2,2) = 1.0;
    W(3,1) = inv_sqrt2; W(3,3) = -inv_sqrt2;
    W(4,0) = inv_sqrt2; W(4,4) = inv_sqrt2;
    
    auto inv_W = inverse(W);
    
    // Transform the U-matrix
    for(int ap1 = 0; ap1 < N_comp; ++ap1)
    for(int ap2 = 0; ap2 < N_comp; ++ap2)
    for(int a1 = 0; a1 < N_comp; ++a1)
    for(int a2 = 0; a2 < N_comp; ++a2){
        U_matrix_cube(ap1,ap2,a1,a2) = 0;
        for(int mp1 = 0; mp1 < N_comp; ++mp1)
        for(int mp2 = 0; mp2 < N_comp; ++mp2)
        for(int m1 = 0; m1 < N_comp; ++m1)
        for(int m2 = 0; m2 < N_comp; ++m2) {
            U_matrix_cube(ap1,ap2,a1,a2) +=
                W(ap1,mp1)*W(ap2,mp2)*
                U_matrix_sph(mp1,mp2,m1,m2)*
                inv_W(m1,a1)*inv_W(m2,a2);
        }
        if(std::abs(U_matrix_cube(ap1,ap2,a1,a2)) > 1e-10){
            
            if(imag(U_matrix_cube(ap1,ap2,a1,a2)) > 1e-10)
                TRIQS_RUNTIME_ERROR << "Cubic harmonics are real, so should be the matrix elements of U.";
            
            using triqs::utility::c;
            using triqs::utility::c_dag;
                        
            for(auto const & s1 : block_names)
            for(auto const & s2 : block_names){
                H += 0.5*real(U_matrix_cube(ap1,ap2,a1,a2))*
                    c_dag(s1,cubic_names[ap1])*
                    c_dag(s2,cubic_names[ap2])*
                    c(s2,cubic_names[a1])*
                    c(s1,cubic_names[a2]);
            }   
        }
    }
    
    // Hybridization function
    using namespace triqs::gf;
    
    auto delta_block = make_gf<imtime>(beta,Fermion,make_shape(N_comp,N_comp),65,full_bins);
    auto tau_mesh = delta_block.mesh();
    
    for(std::size_t tau_index = 0; tau_index < tau_mesh.size(); ++tau_index){
        double tau = tau_mesh.index_to_point(tau_index);
        for(int i = 0; i < N_comp; ++i){
            double value = 0;
            for(auto const& p : delta_params[i])
                value += -p.first*p.first
                         *exp(-tau*p.second)
                         /(1 + exp(-beta*p.second));
            
            delta_block[tau_index](i,i) = value;
        }
    }
    
    std::vector<gf<imtime>> delta_blocks(block_names.size());
    delta_blocks[0] = delta_block;
    delta_blocks[1] = delta_block;
    
    auto delta = make_gf<block_index, gf<imtime>>(block_names,delta_blocks);
    
    // Green's function
    auto g = make_gf<block_index, gf<imtime>>(block_names,
                                    make_gf<imtime>(beta,Fermion,make_shape(N_comp,N_comp),65,full_bins));
    
    // quantum numbers (N_up and N_down)
    std::vector<local_operator_t> qn(2);

    // basis of operators to use
    fundamental_operator_set<std::string, std::string> fops;

    // map indices --> pair of ints
    std::map<std::tuple<std::string,std::string>, std::pair<int,int>> indices_to_ints;
    
    for(int b = 0; b < block_names.size(); ++b){
        for(int c = 0; c < cubic_names.size(); ++c){
            auto b_n = block_names[b];
            auto c_n = cubic_names[c];
            
            qn[b] += n(b_n,c_n);
            fops.add_operator(b_n,c_n);
            
            indices_to_ints[std::make_pair(b_n,c_n)] = std::make_pair(b,c);
        }
    }
        
    // CTQMC solver
    ctqmc krylov_ctqmc(p, H, qn, fops, indices_to_ints, g, delta);
    krylov_ctqmc.solve();
    
    H5::H5File g_file("co_on_cu_test.output.h5",H5F_ACC_TRUNC);
    h5_write(g_file,"g",g);
    
    return EXIT_SUCCESS;
}
